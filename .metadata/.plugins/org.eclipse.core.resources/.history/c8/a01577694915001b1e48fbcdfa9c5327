
/* --------------------------------------------------------------------------
* File: MIPex1.java
* Version 12.8.0
* --------------------------------------------------------------------------
* Licensed Materials - Property of IBM
* 5725-A06 5725-A29 5724-Y48 5724-Y49 5724-Y54 5724-Y55 5655-Y21
* Copyright IBM Corporation 2001, 2017. All Rights Reserved.
*
* US Government Users Restricted Rights - Use, duplication or
* disclosure restricted by GSA ADP Schedule Contract with
* IBM Corp.
* --------------------------------------------------------------------------
*
* MIPex1.java - Entering and optimizing a MIP problem
*/

import java.io.File;
import java.io.IOException;

import ilog.concert.*;
import ilog.cplex.*;
import ilog.cplex.IloCplex.Callback;
import ilog.cplex.IloCplex.Goal;
import ilog.cplex.IloCplex.IncumbentCallback;
import jxl.Workbook;
import jxl.write.Label;
import jxl.write.Number;
import jxl.write.WritableSheet;
import jxl.write.WritableWorkbook;
import jxl.write.WriteException;

public class FirstModel {
	private static final String EXCEL_FILE_LOCATION = "C:\\Users\\Matte\\OneDrive\\Desktop\\Materiale\\Articolo Scheduling\\CplexPrimoModello.xls";
	static WritableWorkbook workBook = null;
	static WritableSheet excelSheet;

	public static void main(String[] args) {
		try {
			// create excel file and init count of rows
			int excelRow = 1;
			createExcelFile();

			for (int n = 20; n <= 120; n += 20) {
				for (int nA = 5; nA <= n / 2; nA += 5) {

					int nB = n - nA;

					// creating the model
					IloCplex model = new IloCplex();

					model.setParam(IloCplex.Param.TimeLimit, 1800);

					// creating variables
					IloNumVar[][] x = new IloNumVar[nA + nB][];
					for (int i = 0; i < nA + nB; i++)
						x[i] = model.boolVarArray(n);

					for (int i = 0; i < nA + nB; i++)
						for (int j = 0; j < n; j++)
							if (i >= nA)
								x[i][j].setName("y[" + i % nA + "," + j + "]");
							else
								x[i][j].setName("x[" + i + "," + j + "]");

					IloNumVar v = model.numVar(Double.MIN_VALUE, Double.MAX_VALUE);
					v.setName("v");
					// creating objective function
					IloLinearNumExpr objectiveFunction = model.linearNumExpr();
					objectiveFunction.addTerm(1, v);
					model.addMinimize(objectiveFunction);

					// creating constraints
					for (int i = 0; i < nA + nB; i++) {
						model.addEq(model.sum(x[i]), 1);

					}

					for (int j = 0; j < n; j++) {
						IloLinearNumExpr j_th_constraints = model.linearNumExpr();
						for (int i = 0; i < nA + nB; i++)
							j_th_constraints.addTerm(1, x[i][j]);
						model.addEq(1, j_th_constraints);
					}

					IloLinearNumExpr linearizationConstraints_1 = model.linearNumExpr();
					linearizationConstraints_1.addTerm(-1, v);
					for (int i = 0; i < nA; i++)
						for (int j = 0; j < n; j++)
							linearizationConstraints_1.addTerm(((double) (j + 1)) / nA, x[i][j]);
					for (int i = nA; i < nA + nB; i++)
						for (int j = 0; j < n; j++)
							linearizationConstraints_1.addTerm(-((double) (j + 1)) / nB, x[i][j]);

					model.addGe(0, linearizationConstraints_1);

					IloLinearNumExpr linearizationConstraints_2 = model.linearNumExpr();
					linearizationConstraints_2.addTerm(-1, v);
					for (int i = 0; i < nA; i++)
						for (int j = 0; j < n; j++)
							linearizationConstraints_2.addTerm(-((double) (j + 1)) / nA, x[i][j]);
					for (int i = nA; i < nA + nB; i++)
						for (int j = 0; j < n; j++)
							linearizationConstraints_2.addTerm(((double) (j + 1)) / nB, x[i][j]);

					model.addGe(0, linearizationConstraints_2);

					long start = System.nanoTime();

					FirstCallback currentCallback = new FirstCallback(nA, nB, start);
					model.use(currentCallback);

					if (model.solve()) {

						// add to file excel the resulting time
						addValueToExcelFile(excelRow, nA, nB, System.nanoTime() - start, model.getObjValue(),
								currentCallback.getTimeToFindOptimum());
						excelRow++;
						if (Math.abs(model.getObjValue() - expectedObjectiveValue(nA, nB)) > 0.0001f)
							throw new RuntimeException("error wrong objective");

					} else
						System.out.println("aiuto");

				}

				excelRow += 3;
			}
			closeExcelFile();
			

		} catch (IloException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}

	private static double expectedObjectiveValue(int nA, int nB) {
		if (nA % 2 == 0 || nB % 2 == 0)
			return 0;
		return ((double) (nA + nB)) / (2 * nA * nB);
	}

	private static void addValueToExcelFile(int excelRow, int nA, int nB, long elapsedTime, double objValue,
			double bestTime) {

		try {

			Number number = new Number(0, excelRow, nA);
			excelSheet.addCell(number);

			number = new Number(1, excelRow, nB);
			excelSheet.addCell(number);

			double timeInSec = elapsedTime / (Math.pow(10, 9));
			Label label = new Label(2, excelRow, String.valueOf(timeInSec));
			excelSheet.addCell(label);

			excelSheet.addCell(new Label(3, excelRow, String.valueOf(objValue)));

			double bestTimeInSec = bestTime / Math.pow(10, 9);
			excelSheet.addCell(new Label(4, excelRow, String.valueOf(bestTimeInSec)));

		} catch (Exception e) {
			throw new RuntimeException("Error adding excel value");
		}

	}

	private static void closeExcelFile() {

		if (workBook != null) {
			try {
				workBook.write();
				workBook.close();
			} catch (IOException e) {
				e.printStackTrace();
			} catch (WriteException e) {
				e.printStackTrace();
			}
		}
	}

	private static void createExcelFile() {

		try {
			workBook = Workbook.createWorkbook(new File(EXCEL_FILE_LOCATION));

			// create an Excel sheet
			excelSheet = workBook.createSheet("Cplex Algorithm", 0);

			// add header into the Excel sheet
			Label label = new Label(0, 0, "nA");
			excelSheet.addCell(label);

			label = new Label(1, 0, "nB");
			excelSheet.addCell(label);

			label = new Label(2, 0, "Time");
			excelSheet.addCell(label);

			label = new Label(3, 0, "objVal");
			excelSheet.addCell(label);

			label = new Label(4, 0, "bestTime");
			excelSheet.addCell(label);

		} catch (Exception e) {
			throw new RuntimeException("error creating excel file");
		}

	}
}

class FirstCallback extends IncumbentCallback {

	int nA;
	int nB;
	long startTime;
	long bestTime;

	public FirstCallback(int nA, int nB, long startTime) {
		this.nA = nA;
		this.nB = nB;
		this.startTime = startTime;
		this.bestTime = Long.MAX_VALUE;
	}

	@Override
	protected void main() throws IloException {

		long currentTime = System.nanoTime();

		if (Math.abs(getObjValue() - getExpectedOptimum()) < 0.0001 && currentTime - startTime < bestTime) {

			bestTime = currentTime - startTime;
		}
	}

	public double getExpectedOptimum() {
		if (nA % 2 == 0 || nB % 2 == 0)
			return 0;
		return ((double) (nA + nB)) / (2 * nA * nB);
	}

	public long getTimeToFindOptimum() {
		return bestTime;
	}
}
